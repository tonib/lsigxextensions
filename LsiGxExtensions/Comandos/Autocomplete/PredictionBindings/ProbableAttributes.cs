using Artech.Architecture.UI.Framework.Language;
using Artech.Udm.Framework;
using LSI.Packages.Extensiones.Comandos.Autocomplete.GxPredictor;
using LSI.Packages.Extensiones.Comandos.Autocomplete.GxPredictor.PredictionGeneration;
using LSI.Packages.Extensiones.Comandos.Autocomplete.KbNames;
using LSI.Packages.Extensiones.Comandos.Autocomplete.KbNames.Tables;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LSI.Packages.Extensiones.Comandos.Autocomplete.PredictionBindings
{
	/// <summary>
	/// Tool to get probable attributes based on attributes instantiated near of the edit caret
	/// </summary>
	class ProbableAttributes
	{
        AutocompleteContext Context;
        PredictionResult Prediction;
        HashesCombinator HashesCombinator;
        ObjectNamesCache NamesCache;
        HashSet<string> AvailableAttNames;

        /// <summary>
        /// Currently typed prefix, lowercase
        /// </summary>
        string PrefixLowercase;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="context">Autocomplete context</param>
        /// <param name="prediction">Prediction generated by the model</param>
        /// <param name="hashesCombinator">Set of most probable names hashes generated by the model</param>
        /// <param name="namesCache">Kb names cache</param>
        /// <param name="availableAttNames">List of available attributes names in current object, lowercase. 
        /// If not null, and includeAttributes is true, only attributes
		/// included in this set will be added to the result (used in transactions to add only attributes in structure part)</param>
        public ProbableAttributes(AutocompleteContext context, PredictionResult prediction, HashesCombinator hashesCombinator, ObjectNamesCache namesCache,
            string prefixLowercase, HashSet<string> availableAttNames)
		{
            Context = context;
            Prediction = prediction;
            HashesCombinator = hashesCombinator;
            NamesCache = namesCache;
            AvailableAttNames = availableAttNames;

            PrefixLowercase = prefixLowercase;
        }

        public HashSet<ObjectNameInfo> GetProbableAttributes(bool useLastReferencedTables)
		{
            HashSet<ObjectNameInfo> result = new HashSet<ObjectNameInfo>();
            if (!NamesCache.Ready)
                return result;

            List<TableName> tables = useLastReferencedTables ? GetReferencedTables() : null;

            AutocompleteItemsGeneration.AddParmNameAsAttribute(Context, PrefixLowercase, result, AvailableAttNames);
            if(useLastReferencedTables)
                GetAttsFromReferencedTablesAndPredictedHash(tables, result);
            GetOtherTablesAttsFromPredictedHash(result);
            if(useLastReferencedTables)
                GetAttsFromReferencedTables(tables, result);
            AddOtherAtts(result);
            return result;
        }

		bool AddAttName(HashSet<ObjectNameInfo> result, AttributeNameInfo attName)
		{
            if (AvailableAttNames != null && !AvailableAttNames.Contains(attName.Name.ToLower()))
                return false;
            return result.Add(attName);
		}

        /// <summary>
        /// Get referenced tables from attribtures instantiated in model input
        /// </summary>
        /// <returns>Most referenced tables</returns>
        List<TableName> GetReferencedTables()
        {
            // Get tables referenced from model input (tokens sequence previous to the caret postiion)
            // Select Guids of referenced attributes in input
            IEnumerable<EntityKey> attsKeys = Prediction.Input.Tokens
                .Where(t => t.NameInfo is AttributeNameInfo)
                .Select(t => t.NameInfo)
                .Cast<AttributeNameInfo>()
                .Where(attName => attName != null)
                .Select(attName => attName.ObjectKey)
                .Distinct();

            // Get tables instantiating these attributes, counting number of times each table is referenced
            Dictionary<TableName, int> tableCounts = new Dictionary<TableName, int>();
            foreach (EntityKey k in attsKeys)
            {
                List<TableName> tables;
                if (!NamesCache.TablesCache.TablesByAttribute.TryGetValue(k, out tables))
                    continue;
                // Discard attributes with too many occurences
                if (tables.Count > 10)
                    continue;

                foreach (TableName table in tables)
                {
                    int count;
                    if (!tableCounts.TryGetValue(table, out count))
                        count = 0;
                    tableCounts[table] = count + 1;
                }
            }

            // Get a list of tables, most referred at start, up to 5 tables
            return tableCounts.OrderByDescending(kv => kv.Value).Select(kv => kv.Key).Take(5).ToList();
        }

        IEnumerable<ObjectNameInfo> AttributeNamesFromPrefix(int[] hashes)
        {
            HashedNames hashedNames = Prediction.KbInfo.ObjectNames.HashedNames;
            if (hashedNames == null)
                return Enumerable.Empty<ObjectNameInfo>();

            return hashedNames
                .GetByHashAndPrefix(hashes, PrefixLowercase)
                .Where(name => name.Type == ChoiceInfo.ChoiceType.Attribute);
        }

        /// <summary>
        /// Calculate most probable attributes from referenced tables in model input and predicted hashes
        /// </summary>
        /// <param name="referencedTables">Referenced tables in input</param>
        /// <param name="result">Probable attributes</param>
        void GetAttsFromReferencedTablesAndPredictedHash(List<TableName> referencedTables, HashSet<ObjectNameInfo> result)
		{
            if (referencedTables.Count == 0)
                return;

            HashedNames hashedNames = Prediction.KbInfo.ObjectNames.HashedNames;
            if (hashedNames == null)
                return;
			Dictionary<EntityKey, List<TableName>> tablesByAttribute = NamesCache.TablesCache.TablesByAttribute;

            // Traverse hashes, from most probable to less probable
            foreach (int[] hashes in HashesCombinator)
            {
				// Attribute names with this hash
                foreach (AttributeNameInfo attName in AttributeNamesFromPrefix(hashes))
                {
                    // Get tables instantiating this attribute
                    List<TableName> attNameTables;
                    if (!tablesByAttribute.TryGetValue(attName.ObjectKey, out attNameTables))
                        continue;

                    // Check if any of the previously referenced tables contains any of these tables
                    if(referencedTables.Any(t => attNameTables.Contains(t)))
					{
                        // It's a probable attribute
                        if(AddAttName(result, attName) && result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                            return;
                    }
                }
            }
        }

        /// <summary>
        /// Calculate most probable attributes from predicted hashes, in any table
        /// </summary>
        /// <param name="result">Probable attributes</param>
        void GetOtherTablesAttsFromPredictedHash(HashSet<ObjectNameInfo> result)
		{
            if (result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                return;

            // Traverse hashes, from most probable to less probable
            foreach (int[] hashes in HashesCombinator)
            {
                // Attribute names with this hash
                foreach (AttributeNameInfo attName in AttributeNamesFromPrefix(hashes))
                {
                    if (AddAttName(result, attName) && result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                        return;
                }
            }
        }

        /// <summary>
        /// Calculate attributes with the current prefix, in input referenced tables 
        /// </summary>
        /// <param name="tables">Referenced tables in input</param>
        /// <param name="result">Probable attributes</param>
        private void GetAttsFromReferencedTables(List<TableName> tables, HashSet<ObjectNameInfo> result)
        {
            if (result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                return;

            // Traverse referenced tables
            foreach (TableName table in tables)
			{
                // Traverse attributes in that table
                foreach(EntityKey attId in table.Attributes)
				{
                    // If attribute starts with typed prefix, add it as result
                    AttributeNameInfo attName = NamesCache.GetNameByKey(attId) as AttributeNameInfo;
                    if (attName == null)
                        continue;
                    if(attName.Name.ToLower().StartsWith(PrefixLowercase))
					{
                        if(AddAttName(result, attName) && result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                            return;
                    }
				}
			}
        }

        /// <summary>
        /// Calculate attributes with current prefix, in any table
        /// </summary>
        /// <param name="result">Probable attributes</param>
        private void AddOtherAtts(HashSet<ObjectNameInfo> result)
		{
            if (result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                return;

            foreach(AttributeNameInfo attName in Autocomplete.NamesCache.GetAttributesByPrefix(PrefixLowercase))
			{
                if (AddAttName(result, attName) && result.Count >= AutocompleteItemsGeneration.MAXENTRIES)
                    return;
            }
        }
    }
}
