using Artech.Architecture.Common.Services;
using Artech.Common.Diagnostics;
using LSI.Packages.Extensiones.Utilidades.VS;
using System;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace LSI.Packages.Extensiones.Utilidades.Logging
{
    /// <summary>
    /// Logger to store and display plain text gx log messages
    /// </summary>
    public class PlainTextLogger : IOutputTarget
    {

        /// <summary>
        /// Are we listening to genexus log?
        /// </summary>
        [XmlIgnore]
        public bool GxLogSubscribed;

        /// <summary>
        /// Optional log on the Genexus output window. It can be null (= do not log on genexus output window)
        /// </summary>
        [XmlIgnore]
        public Log ProcessLog;

        /// <summary>
        /// If it's true, all log text will be stored into the TextLog member.
        /// </summary>
        [XmlIgnore]
        public bool SaveLog;

        /// <summary>
        /// If SaveLog is true, all text log will be stored here
        /// </summary>
        [XmlIgnore]
        public StringBuilder TextLog = new StringBuilder();

        /// <summary>
        /// Level of of a log text entry
        /// </summary>
        public enum LogLevel
        {
            INFO,
            WARNING,
            ERROR
        }

        protected string AddLogLevelPrefix(string text, LogLevel level)
        {
            if (level == LogLevel.ERROR)
                text = CompilerError.ERRORPREFIX + " " + text;
            else if (level == LogLevel.WARNING)
                text = "[WARNING] " + text;
            return text;
        }

        /// <summary>
        /// Log text into the genexus output
        /// </summary>
        /// <param name="text">Text to log</param>
        /// <param name="level">Text level</param>
        private void LogGxOutput(string text, LogLevel level)
        {
            // If genexus log is subscribed, do not write on it, because it will do infinite recursion
            if (ProcessLog == null || GxLogSubscribed)
                return;

            // If we will log an entire line, remove the line break
            if ((level == LogLevel.ERROR || level == LogLevel.WARNING) && text.EndsWith(Environment.NewLine))
                text = text.Substring(0, text.Length - Environment.NewLine.Length);

            if (level == LogLevel.ERROR)
                ProcessLog.Output.AddErrorLine(text);
            else if (level == LogLevel.WARNING)
                ProcessLog.Output.AddWarningLine(text);
            else
                ProcessLog.Output.AddText(text);
        }


        /// <summary>
        /// Log text into the process output
        /// </summary>
        /// <param name="text">Text to log</param>
        /// <param name="level">Text level</param>
        virtual public void LogText(string text, LogLevel level)
        {
            LogGxOutput(text, level);
            if (SaveLog)
                TextLog.Append(AddLogLevelPrefix(text, level));
        }

        /// <summary>
        /// Log text into the process output
        /// </summary>
        /// <param name="text">Text to log</param>
        public void LogText(string text)
        {
            LogText(text, LogLevel.INFO);
        }

        public void LogLine(string lineText, LogLevel level)
        {
            LogText(lineText + Environment.NewLine, level);
        }

        public void LogLine(string lineText)
        {
            LogLine(lineText, LogLevel.INFO);
        }

        public void LogErrorLine(string textLine)
        {
            LogLine(textLine, LogLevel.ERROR);
        }

        public void LogWarningLine(string textLine)
        {
            LogLine(textLine, LogLevel.WARNING);
        }

        /// <summary>
        /// Escribe en el log el contenido de un stream.
        /// La escritura se cancela si se cancela la compilacion
        /// </summary>
        /// <param name="reader"></param>
        public void LogStream(StreamReader reader)
        {
            string line = reader.ReadLine();
            while (line != null)
            {
                LogLine(line);
                line = reader.ReadLine();
            }
        }

        /// <summary>
        /// It suscribes to the genexus output service. All log generated by genexus will be
        /// displayed by this process.
        /// </summary>
        public void SubscribeGXOutput()
        {
            CommonServices.Output.AddListener(Log.BUILD_OUTPUT_ID, this);
            // Do not subscribe own output: We will get messages from other extensions (
            // ex: object checks )
            //CommonServices.Output.AddListener(Log.LSIEXTENSIONS_OUTPUT_ID, this);
            GxLogSubscribed = true;
        }

        /// <summary>
        /// Unsuscribe from the genexus output service. This need to be called if SubscribeGXOutput
        /// was called
        /// </summary>
        public void UnsuscribeGxOutput()
        {
            CommonServices.Output.RemoveListener(this);
            GxLogSubscribed = false;
        }

        #region IOutputTarget implementation

        public void StartSection(string sectionName)
        {
            StartSection(sectionName, sectionName, true);
        }

        public void StartSection(string sectionId, string sectionName)
        {
            StartSection(sectionId, sectionName, true);
        }

        public void StartSection(string sectionName, bool reuseSection)
        {
            StartSection(sectionName, sectionName, reuseSection);
        }

        public void StartSection(string sectionId, string sectionName, bool reuseSection)
        {
            LogLine("[" + sectionName + " started]");
        }

        public void EndSection(string sectionName, bool success)
        {
            EndSection(sectionName, sectionName, success);
        }

        public void EndSection(string sectionId, string sectionName, bool success)
        {
            string msg = "[" + sectionName + " finished ";
            if (success)
                msg += "succesfully]";
            else
                msg += "with errors]";
            LogLine(msg);
        }

        public void Clear() { }

        public void Add(OutputError value)
        {
            OutputDistributor.Add(this, value);
        }

        public void AddText(string value)
        {
            LogText(value);
        }

        public void AddLine(string value)
        {
            LogLine(value);
        }

        public void AddWarningLine(string value)
        {
            LogWarningLine(value);
        }

        public void AddErrorLine(string value)
        {
            LogErrorLine(value);
        }

        public void AddAll(IOutputMessages output, bool textOnly)
        {
            OutputDistributor.AddAll(this, output, textOnly);
        }

        public void Show()
        { }

        #endregion
    }
}
